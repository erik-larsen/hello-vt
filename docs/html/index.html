<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LibVT: LibVT Index Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>LibVT Index Page</h1><h2><a class="anchor" id="intro_usage">
LibVT Usage</a></h2>
<p>To successfully use LibVT in your realtime rendering application you must follow these steps:</p>
<p><b>1</b>.) Adapt your application to use a (single) texture atlas. This means putting all textures (of the objects that should be virtual textured) into a single texture and adjusting the texture coordinates accordingly. You can find more information about rendering with a texure atlas here: <a href="http://download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf">http://download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf</a> <br/>
 NOTE: You don't have to use virtual texturing for every texture in your application and probably shouldn't. e.g. font rendering, particle rendering, skybox rendering or any other objects can be excluded. The following discussion doesn't apply to these objects and their textures shouldn't be put in the texture atlas.<br/>
 NOTE: When placing your textures in the atlas you should place the sub-textures at multiples of the virtual texture tile size so that the virtual texturing system prevents artifacts (Default: 256px)<br/>
 NOTE: The texture atlas you are generating has to have specific dimensions. For virtual texturing without (bilinear) filtering it is exactly "power of two" dimensions, with filtering (tile borders!) slightly smaller depending on the virtual texture tile size. You can of course leave empty white space in the texture atlas or generate ideally sized subtextures from your source artwork. Anyway the adjustment of the texture coordinates must be correct.<br/>
 IMPORTANT: you can use the tool scripts/generateTextureAtlas.py to generate a texture atlas and a texture coordinate offset file. It depends on python and imagemagick. To apply the texture coordinate offsets you can use scripts/offsetObjTexcoords.py *if* you are using .Obj files.<br/>
<br/>
 <b>2</b>.) Your single texture atlas texture will now likely be larger than the maximum texture size (roughly: Intel: 2k^2 ATI: 4k-16k^2 NVIDIA: 8k^2). Create a version downscaled to your maximum texture size. Run your application and render with the downscaled texture atlas. This means every object uses the same texture and the texture coordinates have to be adjusted. If you had any texture streaming or on-demand-loading code in your application you can erase it since you are using just a single texture now which fits into GPU memory. Everything should still work fine, except a lowered texture resolution. If not you don't need to continue, rather find and fix your problem ;-)<br/>
<br/>
 <b>3</b>.) Use the python script "generateVirtualTexureTiles.py" to preprocess the full-resolution version of your texture atlas. Usage options for this script are documented elsewhere. This generates the virtual texture tile store.<br/>
<br/>
 <b>4</b>.) Adjust the values in "LibVT_Config.h" to match your generated virtual texture tile store, your application and it's rendersettings.<br/>
<br/>
 <b>5</b>.) Now adjust your realtime application to use LibVT as documented: <br/>
 At startup call <a class="el" href="_lib_v_t_8h.html#a9927a78d7798699e3d951fa899fd26b7">vtInit() </a> with the path to your tile store, the border width, the mipchain length and the tilesize<br/>
 Call <a class="el" href="_lib_v_t_8h.html#ab95fd80fe3e91cb20e410f2238915eb7">vtGetShaderPrelude() </a> to obtain the prelude to prepend to the shaders and load the readback and renderVT shaders.<br/>
 When OpenGL is callable call <a class="el" href="_lib_v_t_8h.html#a41a8053f6cfc5cf8f827f6b1f89b0efd">vtPrepare() </a> and pass it the shader objects.<br/>
 Call <a class="el" href="_lib_v_t_8h.html#a33a38c85152447cf555a7a905353204c">vtReshape() </a> now with the screen width, height, as well as fov, nearplane and farplane (only imporant in readback reduction mode). This call must also be made every time any of these values change, i.e. at viewport resize time.<br/>
 Now in the renderloop, call <a class="el" href="_lib_v_t_8h.html#a7d4070be203c7f025f0ef21f7b0a49cc">vtPrepareReadback() </a>, render with the readback shader, call <a class="el" href="_lib_v_t_8h.html#a5a89d97f074a77cfd7e49738e8beb933">vtPerformReadback() </a>, <a class="el" href="_lib_v_t_8h.html#aaf4122a00fc8eef7b2534352407b418c">vtExtractNeededPages() </a>, <a class="el" href="_lib_v_t_8h.html#a1b5f0f43f71460c980ec9574ba90d0a2">vtMapNewPages() </a>, and then render with the renderVT shader. Additionally pass the result of <a class="el" href="_lib_v_t_8h.html#af4e213c5d72893725a3490513b17c066">vtGetBias() </a> to both shaders as value for "mip_bias" each frame if you have the dynamic lod adjustment turned on.<br/>
 At shutdown call <a class="el" href="_lib_v_t_8h.html#a6cdbd1da7fa7009e1ca22ec280e7e20f">vtShutdown() </a><br/>
<br/>
 <b>EXAMPLES:</b> <br/>
 <a class="el" href="simpleexample.html">SimpleExample</a> Simple LibVT usage example<br/>
 <a class="el" href="openclexample.html">OpenCLExample</a> LibVT usage example for a single pass solution using MRT and OpenCL buffer reduction<br/>
 <a class="el" href="cgexample.html">CGExample</a> LibVT usage example with Cg instead of GLSL<br/>
 <br/>
 NOTE: The "readback" shader has to be used exactly as provided and can't be modified. As seen in the sample you have to use this shader during rendering your virtual textured objects in the pre-pass.<br/>
 NOTE: The "renderVT" shader can be modified as you wish, but you have to retain the virtual texture functions and use sampleVirtualTexture(calculateVirtualTextureCoordinates()) to sample from the virtual texture. Don't forget to prepend the prelude to the shadercode.<br/>
 NOTE: As seen in the code, after you've finished rendering the virtual textures objects you can render other objects to your liking. You can use any shaders you wish. Be careful never to use texture units that LibVT uses, namely as defined in "LibVT_Config.h" TEXUNIT_FOR_PAGETABLE, TEXUNIT_FOR_PHYSTEX and TEXUNIT_FOR_MIPCALC.<br/>
 NOTE: Many other requirements are listed throughout the remaining documentation. Read it carefully!<br/>
<br/>
<br/>
</p>
<h2><a class="anchor" id="intro_pipeline">
LibVT Content Pipeline</a></h2>
<p>This section describes the usage of the preprocessing scripts of LibVT, i.e. how to adapt your content for virtual texturing rendering. We start with an short description of the individual scripts and then give three increasingly complex examples. Make sure you have already read the above section "LibVT Usage". Please also note that all scripts have "built in help", pass them bogus and they will print out their usage instructions including possible options.<br/>
</p>
<p><b>generateTextureAtlas.py:</b> Produces one big texture (i.e. a texture atlas) out of many small individual (sub-)textures. It also produces a "coordinate offset file". <br/>
 <b>offsetObjTexcoords.py:</b> Applies a "coordinate offset file" to a Wavefront Object File (.Obj).<br/>
 <b>generateVirtualTextureTiles.py:</b> Takes one big texture or texture atlas and produces the "virtual texture tile store" needed for virtual texturing rendering. This script has a strict requirement on the input image size, which depends on the tile size and the tile border size. Find out the neccessary size for your desired border and tilesize before creating a texture atlas of the wrong size!<br/>
 <b>mergeVirtualTextureTiles.py:</b> Merges 4, 16 or 64 "virtual texture tile stores" into a single, larger one.<br/>
 <b>convertVirtualTextureTiles.py:</b> Converts a "virtual texture tile stores" into another image compression format (e.g. "bmp" -&gt; "jpg")<br/>
<br/>
</p>
<p>Here are multiple examples, detailing the pipeline in simple and more complex cases. Please read through the simpler cases even if you are only interested in the complex one, since not all the information is provided 3 times.</p>
<h3><a class="anchor" id="case_one">
Simple Case</a></h3>
<p>Terrain textured with a single 32k texture:<br/>
</p>
<div class="fragment"><pre class="fragment"> generateVirtualTextureTiles -b=1 -t=128 -f=jpg imputimage.png 
</pre></div><p> This produces a "virtual texture tile store" using tiles with a size of 128 and a border of 1. The tile format is jpg. The inputimage.png must be 32256^2 pixel.<br/>
 The output is saved in a folder in the current directory with a name similar to the input image name, without the extension. </p>
<div class="fragment"><pre class="fragment"> generateVirtualTextureTiles -b=4 -t=256 -f=jpg imputimage.png 
</pre></div><p> This produces a "virtual texture tile store" using tiles with a size of 256 and a border of 4. The tile format is jpg. The inputimage.png must be 31744^2 pixel.</p>
<h3><a class="anchor" id="case_two">
Atlas Case</a></h3>
<p>Scene composed of multiple textured objects with a combined texture requirement of 32k^2:<br/>
</p>
<p>Since the scene contains multiple distinct textures they have to be combined into a single texture atlas. Please note you can also do this with alternative texture atlas tools, but only the usage of the script contained in LibVT is described here. Before you start you must decide on the tilesize and bordersize to use, because this affects the required atlas size. In this example we want to use 128 tiles with 1px border, so lets start by finding out the required atlas size for this settings:<br/>
</p>
<div class="fragment"><pre class="fragment"> generateVirtualTextureTiles -b=1 -t=128 somepicture_which_surely_is_the_wrong_size.bmp 
</pre></div><p>This gives us: </p>
<div class="fragment"><pre class="fragment"> Error: input image must be in: 4032^2, 8064^2, 16128^2, 32256^2, 64512^2, 129024^2 
</pre></div><p>So now we know that the required atlas size for the settings we want is 32256.</p>
<div class="fragment"><pre class="fragment"> generateTextureAtlas -d=output_dir/ -s=32256 tex*.jpg 
</pre></div><p> This produces a texture atlas named "_texture_atlas00.bmp" out of all images starting with "tex" and of format jpg in the current directory. It also produces a texture coordinate offset file called "_texture_atlas_offset.off". All output files are stored to "output_dir". On windows it helps to pass "-c=\path\to\imagemagick\" to prevent the script from picking up the windows "convert" tool instead of the image magick one.</p>
<div class="fragment"><pre class="fragment"> offsetObjTexcoords -o=scene_object.obj -t=_texture_atlas_offset.off -d=output_dir/ 
</pre></div><p> This applies the texture coordinate offsets from the offset file onto the .Obj file "scene_object.obj". Of course the .Obj file must be accompanied by a .Mtl file and the relative path and the filename of the .Mtl file must be given in the "mtllib" section (i.e. everything works unless you moved/renamed the .Mtl file). "scene_object_transformed.obj" and "scene_object_transformed.mtl" are saved in "output_dir". You can apply the offsets to all your obj files in one go if you have a proper shell, here is code for bash: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> i in *obj; <span class="keywordflow">do</span> offsetObjTexcoords -o=$i -t=_texture_atlas_offset.off; done 
</pre></div><p> And here is code for "cmd.exe": </p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> %i in (*.obj) do offsetObjTexcoords -o=%i -t=_texture_atlas_offset.off 
</pre></div><p>The texture atlas has been created, the offsets have been applied, the last step is producing the actual "virtual texture tile store" out of the atlas:</p>
<div class="fragment"><pre class="fragment"> generateVirtualTextureTiles -b=1 -t=128 -f=jpg _texture_atlas00.bmp 
</pre></div><p> This produces a "virtual texture tile store" using tiles with a size of 128 and a border of 1 out of the texture atlas. The tile format is jpg. The _texture_atlas00.bmp must be exatly 32256^2 pixel (and it is, see options to generateTextureAtlas above).</p>
<h3><a class="anchor" id="case_three">
Big Atlas Case</a></h3>
<p>Scene composed of multiple textured objects with a combined texture requirement of 128k^2:<br/>
</p>
<p>This case is similar to the above one, but images of size 32k^2 or larger are nearly impossible to process, necessitating more intermediate files and more intermediate steps. Note that this example uses 64 intermediate files, you could probably get by with only 16, and producing a 64k^2 virtual texture could get by even with only 4 intermediate files. Adapt as neccessary.</p>
<div class="fragment"><pre class="fragment"> generateTextureAtlas -d=output_dir/ -s=129024 -n=3 tex*.jpg 
</pre></div><p> This produces a texture atlas named "_texture_atlas00.bmp" out of all images starting with "tex" and of format jpg in the current directory. It also produces a texture coordinate offset file called "_texture_atlas_offset.off". All output files are stored to "output_dir". The -n=3 option tells the script to produce 4^3, i.e. 64 output images to avoid creating a impossible large intermediate file.</p>
<div class="fragment"><pre class="fragment"> offsetObjTexcoords -o=scene_object.obj -t=_texture_atlas_offset.off -d=output_dir/ 
</pre></div><p> This applies the texture coordinate offsets from the offset file onto the .Obj file "scene_object.obj". Of course the .Obj file must be accompanied by a .Mtl file and the relative path and the filename of the .Mtl file must be given in the "mtllib" section (i.e. everything works unless you moved/renamed the .Mtl file). "scene_object_transformed.obj" and "scene_object_transformed.mtl" are saved in "output_dir". You can apply the offsets to all your obj files in one go if you have a proper shell, here is code for bash: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> i in *obj; <span class="keywordflow">do</span> offsetObjTexcoords -o=$i -t=_texture_atlas_offset.off; done 
</pre></div><p>The texture atlas has been created, the offsets have been applied, we now create 64 virtual textures out of the 64 parts of the texture atlas:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> i in _t*bmp; <span class="keywordflow">do</span> generateVirtualTextureTiles -b=1 -f=bmp -t=128 $i; done 
</pre></div><p>This produces a "virtual texture tile store" out of each of the parts of the texture atlas. We need to use a uncompressed format (bmp) because we process the tiles further. This example assumes a proper shell, either adapt the example or do the dumb thing and repeat this with 00 replaced with 01, 02, 04, 05, 06, 07, 10, 11...up to 77:</p>
<div class="fragment"><pre class="fragment"> generateVirtualTextureTiles -b=1 -f=bmp -t=128 _texture_atlas00.bmp 
</pre></div><p>The 64 individual virtual texture tile stored need to be merged:</p>
<div class="fragment"><pre class="fragment"> mergeVirtualTextureTiles -o=merged/ -l=8 -b=1 _texture_atlas00 _texture_atlas10 _texture_atlas20 _texture_atlas30 _texture_atlas40 _texture_atlas50 _texture_atlas60 _texture_atlas70 _texture_atlas01 _texture_atlas11 _texture_atlas21 _texture_atlas31 _texture_atlas41 _texture_atlas51 _texture_atlas61 _texture_atlas71 _texture_atlas02 _texture_atlas12 _texture_atlas22 _texture_atlas32 _texture_atlas42 _texture_atlas52 _texture_atlas62 _texture_atlas72 _texture_atlas03 _texture_atlas13 _texture_atlas23 _texture_atlas33 _texture_atlas43 _texture_atlas53 _texture_atlas63 _texture_atlas73 _texture_atlas04 _texture_atlas14 _texture_atlas24 _texture_atlas34 _texture_atlas44 _texture_atlas54 _texture_atlas64 _texture_atlas74 _texture_atlas05 _texture_atlas15 _texture_atlas25 _texture_atlas35 _texture_atlas45 _texture_atlas55 _texture_atlas65 _texture_atlas75 _texture_atlas06 _texture_atlas16 _texture_atlas26 _texture_atlas36 _texture_atlas46 _texture_atlas56 _texture_atlas66 _texture_atlas76 _texture_atlas07 _texture_atlas17 _texture_atlas27 _texture_atlas37 _texture_atlas47 _texture_atlas57 _texture_atlas67 _texture_atlas77 
</pre></div><p>Note that the order is important and must be similar even with 16 or 4 intermediate atlas folders, i.e. for 4 folders its "_texture_atlas00 _texture_atlas10 _texture_atlas01 _texture_atlas11". If your border is not 1, adapt the -b option. If your mipmap-chain length is different (different tilesize or virtual texture size), adapt the -l option. The -l option must be set to specify the mipmap chain length of the input folders, i.e. if they have tiles_b0_level0 throughout tiles_b0_level7, you must specify -l=8.<br/>
 Now, the only thing left to do is convert this virtual texture tile store, because a store of this size in bmp is quite big:</p>
<div class="fragment"><pre class="fragment"> convertVirtualTextureTiles -b=1 -fi=bmp -fo=jpg merged 
</pre></div><p>This converts the tile store in place, now the store in "merged/" is the finished version.<br/>
</p>
<h3><a class="anchor" id="case_add">
Addendum</a></h3>
<p>The generateTextureAtlas script has a "-i=" option to place a number of input image in a regular predefined grid. This allows controlling the placement of some input images in the atlas. This can be useful if you want some images placed in a special way, e.g. because they cover terrain and had to be split because of size limitations. Here is a example that demonstrates how the atlas for the new york scene was built:</p>
<div class="fragment"><pre class="fragment"> generateTextureAtlas -s=129024 -n=3 -i=4:4:__p1ground.png:__p2ground.png:__p3ground.png:__p4ground.png:__p5ground.png:__p6ground.png:__p7ground.png:__p8ground.png:__p9ground.png:__p10ground.png:__p11ground.png:__p12ground.png:__p13ground.png:__p14ground.png:__p15ground.png:__p16ground.png small*.jpg p1b* p2b* p3b* p5b* p6b* p8b* p9b* p11b* p12b* p13b* p14b* p15b* p16b* 
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jun 20 23:49:20 2010 for LibVT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
